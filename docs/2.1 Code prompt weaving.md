# 2.1 Code prompt weaving

#!/usr/bin/env python3

# *coding: utf-8 -*

"""
[Photostudio.io](http://photostudio.io/) — Step 2/6: JSON → Prompt Weaving (v2.1)

- Builds a sectioned, natural-language prompt from Step 1 `garment_analysis.json`
- Adds an anti-hallucination guardrail (single, compact, first line)
- Encodes ghost-mannequin rendering rules (interior depth, sleeve/neck hollowness)
- Runs semantic preflight checks and writes warnings to metadata (optionally append to prompt)
- Determinism knobs (seed, temperature, top_p) and template info recorded in metadata only

Python: 3.10+
"""

from **future** import annotations

import argparse
import json
from dataclasses import dataclass, asdict
from pathlib import Path
from typing import Any, Dict, List, Optional

# ------------------------

# Config dataclasses (metadata only)

# ------------------------

@dataclass
class StyleKit:
background_rgb: str = "255,255,255"
lighting: str = "High-key, soft, even studio light"
canvas_size_px: int = 2048
frame_fill_pct: int = 85
color_space: str = "sRGB"
delta_e_tolerance: float = 2.0
template_id: str = "photostudio_ghost_mannequin_v2"
consistency_anchor: str = "ecommerce_professional"

@dataclass
class GenControls:
temperature: float = 0.0
top_p: float = 0.15
seed: Optional[int] = None
multimodal_integration: bool = True
verification_level: str = "high"  # metadata only

@dataclass
class PromptBundle:
prompt: str
controls: GenControls
notes: Dict[str, Any]
semantic_warnings: List[str]

# ------------------------

# Utilities

# ------------------------

def _get(d: Dict, path: List[str], default=None):
cur = d
for key in path:
if not isinstance(cur, dict) or key not in cur:
return default
cur = cur[key]
return cur

def bullets(lines: List[str]) -> str:
return "\n".join(f"• {line}" for line in lines if line and line.strip())

# ------------------------

# Semantic preflight (warnings only)

# ------------------------

def semantic_warnings_from_json(j: Dict[str, Any]) -> List[str]:
warnings: List[str] = []

```
category = (_get(j, ["garment_categorization", "primary_classification", "category"], "") or "").lower()
specific = (_get(j, ["garment_categorization", "primary_classification", "specific_type"], "") or "").lower()
sleeves = (_get(j, ["garment_categorization", "style_attributes", "sleeves"], "") or "").lower()
primary_closure = (_get(j, ["construction_details", "closures", "primary_closure"], "") or "").lower()

# Zipper on likely pullover types
if primary_closure == "zipper" and specific in {
    "t-shirt", "tee", "tank-top", "tank", "sweater_pullover", "hoodie_pullover"
}:
    warnings.append("Zipper present on a pullover/basic top—verify classification and closure type.")

# Sleeves vs garment type
if specific in {"tank-top", "camisole"} and sleeves not in {"sleeveless", "unknown", ""}:
    warnings.append("Tank/Cami with non-sleeveless value—verify sleeves attribute.")

# Color presence
primary_hex = _get(j, ["color_extraction", "primary_color", "hex_value"])
if not primary_hex:
    warnings.append("Primary color hex missing—prompt will rely on color name; verify color extraction.")

# Pocket contradictions
pockets_present = bool(_get(j, ["construction_details", "critical_features", "pockets", "present"]))
pocket_type = (_get(j, ["construction_details", "critical_features", "pockets", "type"], "") or "").lower()
if not pockets_present and pocket_type not in {"", "none"}:
    warnings.append("Pocket type specified while pockets.present=false—verify pockets fields.")

# Mask coverage too small (downstream framing issues)
cov = _get(j, ["segmentation_results", "mask_coverage"])
if isinstance(cov, (int, float)) and cov < 0.15:
    warnings.append("Very small mask coverage—verify framing and segmentation.")

# Buttons closure but zero count
closure_count = _get(j, ["construction_details", "closures", "closure_count"], 0)
if primary_closure == "buttons" and int(closure_count or 0) == 0:
    warnings.append("Closure type is buttons but closure_count=0—verify closure fields.")

# Pattern vs color-variety mismatch
pat = (_get(j, ["color_extraction", "pattern_analysis", "pattern_type"], "") or "").lower()
variety = _get(j, ["color_extraction", "color_distribution", "color_variety"], 1)
if pat == "solid" and isinstance(variety, int) and variety > 1:
    warnings.append("Solid pattern with multiple dominant colors—verify color/pattern analysis.")

# Brand visible but no brand info
if bool(_get(j, ["brand_information", "brand_visible"])) and not (
    (_get(j, ["brand_information", "brand_name"]) or "").strip().lower() not in {"", "unknown"}
    or bool(_get(j, ["brand_information", "label_text"]))
):
    warnings.append("Brand visible but brand_name/label_text missing—verify brand fields.")

return warnings

```

# ------------------------

# Prompt Sections

# ------------------------

def section_non_negotiable_facts(j: Dict[str, Any]) -> str:
cat = _get(j, ["garment_categorization", "primary_classification", "category"], "unknown")
typ = _get(j, ["garment_categorization", "primary_classification", "specific_type"], "unknown")
fit = _get(j, ["garment_categorization", "style_attributes", "fit_type"], "regular")
sleeves = _get(j, ["garment_categorization", "style_attributes", "sleeves"], "unknown")
neckline = _get(j, ["garment_categorization", "style_attributes", "neckline"], "unknown")

```
color_hex = _get(j, ["color_extraction", "primary_color", "hex_value"])
color_name = _get(j, ["color_extraction", "primary_color", "color_name"], "unknown")

mat_type = _get(j, ["fabric_analysis", "material_detection", "material_type"], "unknown")
weight = _get(j, ["fabric_analysis", "texture_classification", "fabric_weight"], "medium")
texture = _get(j, ["fabric_analysis", "texture_classification", "primary_texture"], "smooth")
drape = _get(j, ["fabric_analysis", "material_detection", "drape_behavior"], "moderate")

closures = _get(j, ["construction_details", "closures"], {}) or {}
primary_closure = (closures.get("primary_closure", "unknown") or "unknown")
closure_count = int(closures.get("closure_count", 0) or 0)

pockets = _get(j, ["construction_details", "critical_features", "pockets"], {}) or {}
pockets_present = bool(pockets.get("present"))
pocket_type = pockets.get("type", "none")

brand_visible = bool(_get(j, ["brand_information", "brand_visible"]))
brand_name = _get(j, ["brand_information", "brand_name"], "unknown")
label_text = _get(j, ["brand_information", "label_text"], "")

facts: List[str] = []
facts.append(f"Garment: {cat} → {typ} (fit: {fit}; sleeves: {sleeves}; neckline: {neckline}).")
if color_hex:
    facts.append(f"Primary color: {color_name} (hex {color_hex}).")
else:
    facts.append(f"Primary color: {color_name} (hex unavailable).")
facts.append(f"Fabric: {mat_type}, {weight} weight, {texture} texture, {drape} drape behavior.")
if primary_closure == "buttons" and closure_count:
    facts.append(f"Closures: {closure_count} front buttons.")
elif primary_closure != "unknown":
    facts.append(f"Closures: {primary_closure}.")
if pockets_present:
    facts.append(f"Pockets: {pocket_type}.")
if brand_visible or label_text or (brand_name and brand_name != "unknown"):
    brand_bits = []
    if brand_name and brand_name != "unknown":
        brand_bits.append(f'brand "{brand_name}"')
    if label_text:
        brand_bits.append(f'label text "{label_text}"')
    if brand_bits:
        facts.append("Brand elements present: " + ", ".join(brand_bits) + ".")

return "NON-NEGOTIABLE FACTS:\\n" + bullets(facts)

```

def section_style_guide(style: StyleKit) -> str:
rules = [
f"Background: pure white (RGB {style.background_rgb}); no shadows or gradients.",
f"Lighting: {style.lighting}.",
f"Canvas: exactly {style.canvas_size_px}×{style.canvas_size_px} pixels, square.",
f"Framing: garment fills ~{style.frame_fill_pct}% of the frame, centered.",
f"Color: {style.color_space} with ΔE < {style.delta_e_tolerance} to specified hex values.",
"Camera angle: straight-on frontal view with minimal perspective distortion.",
]
return "MANDATORY STYLE GUIDE:\n" + bullets(rules)

def section_garment_aware_rules(j: Dict[str, Any]) -> str:
sleeves = (_get(j, ["garment_categorization", "style_attributes", "sleeves"], "unknown") or "").lower()
neckline = _get(j, ["garment_categorization", "style_attributes", "neckline"], "unknown")
material = (_get(j, ["fabric_analysis", "material_detection", "material_type"], "unknown") or "").lower()
drape = _get(j, ["fabric_analysis", "material_detection", "drape_behavior"], "moderate")
primary_closure = (_get(j, ["construction_details", "closures", "primary_closure"], "unknown") or "").lower()

```
rules: List[str] = []

# Ghost-mannequin interior rendering
if sleeves not in {"sleeveless", "unknown", ""}:
    rules.append("Sleeve openings must appear hollow with subtle interior depth shading.")
rules.append("Neckline opening should render as a hollow opening with realistic interior curvature.")
rules.append("Interior spaces (neck/arms) require soft, natural gradient shadowing.")

# Fabric-aware drape cues
if material in {"cotton", "linen", "viscose"}:
    rules.append(f"Fabric behavior: {material}—natural creasing and soft {drape} drape.")
elif material in {"polyester", "nylon", "synthetic", "polyester_blend"}:
    rules.append(f"Fabric behavior: {material}—more structured form with minimal creasing.")
elif material in {"silk", "satin"}:
    rules.append(f"Fabric behavior: {material}—fluid drape with subtle surface sheen.")

# Zipper logic (only if interior is intended to show)
if primary_closure == "zipper":
    rules.append("If interior/lining is specified in the JSON, you may render the front zipper ~75% open to reveal it; otherwise keep the zipper closed.")

# Brand/label handling
brand_visible = bool(_get(j, ["brand_information", "brand_visible"]))
if brand_visible:
    rules.append("Ensure brand label/logo remains legible and at the JSON-specified position; do not obscure or move it.")

# Pockets
if bool(_get(j, ["construction_details", "critical_features", "pockets", "present"])):
    rules.append("Show all JSON-specified pockets with realistic depth and subtle shadowing.")

return "GARMENT-AWARE RENDERING RULES:\\n" + bullets(rules)

```

def section_forbidden_edits(j: Dict[str, Any]) -> str:
primary_closure = (_get(j, ["construction_details", "closures", "primary_closure"], "unknown") or "").lower()
pockets_present = bool(_get(j, ["construction_details", "critical_features", "pockets", "present"]))
bans = [
"Render only features present in the facts list; do not invent or add missing details.",
"Do not change garment category, type, or proportions.",
"Do not deviate from specified hex colors or introduce new colors.",
"Do not add backgrounds, gradients, props, reflections, or cast shadows.",
"Do not move, resize, or alter brand elements or labels.",
]
if primary_closure != "zipper":
bans.append("Do not add a zipper.")
if primary_closure != "buttons":
bans.append("Do not add buttons.")
if not pockets_present:
bans.append("Do not add pockets.")

```
return "FORBIDDEN EDITS:\\n" + bullets(bans)

```

def section_quality_checks(style: StyleKit, j: Dict[str, Any]) -> str:
color_hex = _get(j, ["color_extraction", "primary_color", "hex_value"])
checks = [
f"Color accuracy: {'matches ' + color_hex if color_hex else 'matches specified primary color'} within ΔE < {style.delta_e_tolerance}.",
"Background: pure white, no banding or tint.",
f"Resolution: exactly {style.canvas_size_px}×{style.canvas_size_px} pixels.",
"Ghost effect: interior openings (neck/sleeves) read as hollow with convincing depth.",
"JSON fidelity: all specified features present; none invented.",
]

```
if bool(_get(j, ["construction_details", "critical_features", "pockets", "present"])):
    checks.append("Pockets: all specified pockets visible and correctly positioned.")
if (_get(j, ["construction_details", "closures", "primary_closure"], "") or "").lower() == "zipper":
    checks.append("Zipper: closed unless JSON specifies interior/lining visibility; if open, reveal correct interior color/material.")
if bool(_get(j, ["brand_information", "brand_visible"])):
    checks.append("Brand: labels/logos legible and in the JSON-specified position.")

return "CRITICAL QUALITY CHECKS:\\n" + bullets(checks)

```

# ------------------------

# Main weaver

# ------------------------

def build_prompt_from_json(
j: Dict[str, Any],
style: StyleKit,
controls: GenControls,
include_warnings_in_prompt: bool = False
) -> PromptBundle:
warnings = semantic_warnings_from_json(j)

```
guardrail = (
    "Render only details present in NON-NEGOTIABLE FACTS; if a detail is missing or uncertain, "
    "keep it neutral or omit it. Do not invent features, text, logos, or colors."
)
negative = "No mannequin, no human parts, no props, no shadows/reflections, no background gradients."

sections = [
    guardrail,
    section_non_negotiable_facts(j),
    section_style_guide(style),
    negative,
    section_garment_aware_rules(j),
    section_forbidden_edits(j),
    section_quality_checks(style, j),
]

if include_warnings_in_prompt and warnings:
    sections.append("SEMANTIC WARNINGS (review before generation):\\n" + bullets(warnings))

prompt_text = "\\n\\n".join(sections)

notes = {
    "template_id": style.template_id,
    "consistency_anchor": style.consistency_anchor,
    "category": _get(j, ["garment_categorization", "primary_classification", "category"], "unknown"),
    "specific_type": _get(j, ["garment_categorization", "primary_classification", "specific_type"], "unknown"),
    "primary_hex": _get(j, ["color_extraction", "primary_color", "hex_value"]),
    "frame_fill_pct": style.frame_fill_pct,
    "delta_e_tolerance": style.delta_e_tolerance,
    "semantic_warning_count": len(warnings),
}

return PromptBundle(
    prompt=prompt_text,
    controls=controls,
    notes=notes,
    semantic_warnings=warnings
)

```

# ------------------------

# CLI

# ------------------------

def main():
ap = argparse.ArgumentParser(
description="[Photostudio.io](http://photostudio.io/) — Step 2/6: Build sectioned prompts from garment_analysis.json"
)
ap.add_argument("json_path", help="Path to garment_analysis.json from Step 1")
ap.add_argument(
"-o", "--out",
help="Output path for prompt text (default: enhanced_prompt.txt alongside JSON)"
)
ap.add_argument("--size", type=int, default=2048, help="Canvas size (px, square). Default: 2048")
ap.add_argument("--seed", type=int, help="Deterministic seed (metadata only)")
ap.add_argument("--temperature", type=float, default=0.0, help="Temperature (metadata only). Default: 0.0")
ap.add_argument("--top_p", type=float, default=0.15, help="Top-p (metadata only). Default: 0.15")
# Python 3.9+:
ap.add_argument(
"--include-warnings-in-prompt",
action=argparse.BooleanOptionalAction,
default=False,
help="If set, appends a short SEMANTIC WARNINGS section when warnings exist."
)

```
args = ap.parse_args()

json_path = Path(args.json_path)
with json_path.open("r", encoding="utf-8") as f:
    j = json.load(f)

style = StyleKit(canvas_size_px=args.size)
controls = GenControls(seed=args.seed, temperature=args.temperature, top_p=args.top_p)

bundle = build_prompt_from_json(
    j=j,
    style=style,
    controls=controls,
    include_warnings_in_prompt=bool(args.include_warnings_in_prompt)
)

# Write prompt
out_path = Path(args.out) if args.out else json_path.with_name("enhanced_prompt.txt")
out_path.parent.mkdir(parents=True, exist_ok=True)
out_path.write_text(bundle.prompt, encoding="utf-8")

# Write metadata next to prompt
meta = {
    "controls": asdict(bundle.controls),
    "notes": bundle.notes,
    "semantic_warnings": bundle.semantic_warnings,
    "style": asdict(style),
    "file_inputs": {"garment_analysis": str(json_path)},
    "performance_hints": {
        "determinism": "Use provided seed/low temperature/top_p in your generator.",
        "consistency": "Reuse same template_id for series images to minimize drift."
    }
}
meta_path = out_path.with_suffix(".meta.json")
meta_path.write_text(json.dumps(meta, indent=2), encoding="utf-8")

print(f"✓ Prompt saved to: {out_path}")
print(f"✓ Metadata saved to: {meta_path}")
if bundle.semantic_warnings:
    print(f"⚠ Semantic warnings: {len(bundle.semantic_warnings)} (see metadata)")

```

if **name** == "**main**":
main()